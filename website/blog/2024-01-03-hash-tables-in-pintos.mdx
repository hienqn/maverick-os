---
slug: hash-tables-in-pintos
title: "Data Structures: Hash Tables in PintOS"
tags: [data-structures, pintos, c-programming]
description: Learn how PintOS implements efficient hash tables for kernel data structures
---

import InteractiveDiagram from '@site/src/components/InteractiveDiagram';
import Quiz from '@site/src/components/Quiz';

PintOS uses hash tables extensively for managing threads, pages, and file descriptors. Let's explore this fundamental data structure.

{/* truncate */}

## Why Hash Tables?

Operating systems need fast lookups. When handling a page fault, the kernel must quickly find the metadata for a virtual address. Linear search through a list would be O(n) - far too slow. Hash tables provide O(1) average-case lookup.

## PintOS Hash Table Structure

<InteractiveDiagram
  title="Hash Table with Separate Chaining"
  width={700}
  height={400}
  nodes={[
    { id: 'hash', label: 'struct hash', x: 50, y: 50, width: 120, height: 60, color: '#4CAF50', description: 'Main hash table structure' },
    { id: 'bucket0', label: 'buckets[0]', x: 250, y: 30, width: 100, height: 40, color: '#2196F3', description: 'First bucket (linked list)' },
    { id: 'bucket1', label: 'buckets[1]', x: 250, y: 80, width: 100, height: 40, color: '#2196F3', description: 'Second bucket' },
    { id: 'bucket2', label: 'buckets[2]', x: 250, y: 130, width: 100, height: 40, color: '#2196F3', description: 'Third bucket' },
    { id: 'elem1', label: 'hash_elem', x: 420, y: 30, width: 100, height: 40, color: '#FF9800', description: 'Element in bucket 0' },
    { id: 'elem2', label: 'hash_elem', x: 560, y: 30, width: 100, height: 40, color: '#FF9800', description: 'Chained element' },
    { id: 'elem3', label: 'hash_elem', x: 420, y: 80, width: 100, height: 40, color: '#FF9800', description: 'Element in bucket 1' },
    { id: 'spt', label: 'spt_entry', x: 420, y: 200, width: 120, height: 80, color: '#9C27B0', description: 'Your data structure embeds hash_elem' },
    { id: 'hash_elem_embed', label: 'hash_elem', x: 440, y: 240, width: 80, height: 30, color: '#FF9800', description: 'Embedded hash element' },
  ]}
  edges={[
    { from: 'hash', to: 'bucket0', label: '' },
    { from: 'hash', to: 'bucket1', label: '' },
    { from: 'hash', to: 'bucket2', label: '' },
    { from: 'bucket0', to: 'elem1', label: '' },
    { from: 'elem1', to: 'elem2', label: 'next' },
    { from: 'bucket1', to: 'elem3', label: '' },
    { from: 'elem1', to: 'spt', label: 'hash_entry()', dashed: true },
  ]}
/>

## The Code

```c
/* Hash table structure */
struct hash {
  size_t elem_cnt;           /* Number of elements */
  size_t bucket_cnt;         /* Number of buckets */
  struct list *buckets;      /* Array of bucket lists */
  hash_hash_func *hash;      /* Hash function */
  hash_less_func *less;      /* Comparison function */
  void *aux;                 /* Auxiliary data */
};

/* Element embedded in your data structure */
struct hash_elem {
  struct list_elem list_elem; /* For chaining in bucket */
};
```

## The Embedding Pattern

PintOS uses **intrusive data structures**. Instead of storing pointers to your data, you embed a `hash_elem` inside your structure:

```c
/* Supplemental page table entry */
struct spt_entry {
  void *upage;              /* Virtual address (key) */
  void *kpage;              /* Kernel virtual address */
  bool writable;            /* Write permission */

  struct hash_elem elem;    /* Embedded hash element */
};
```

To recover your structure from a `hash_elem`, use `hash_entry`:

```c
struct spt_entry *spte = hash_entry(e, struct spt_entry, elem);
```

This macro uses `offsetof` to calculate the address of the containing structure.

## When to Use Hash Tables

| Use Case | Why Hash Table? | Alternative |
|----------|-----------------|-------------|
| Supplemental Page Table | O(1) lookup by virtual address | List: O(n) |
| Frame Table | Quick frame-to-page mapping | Array: wastes memory |
| File Descriptor Table | Fast fd-to-file lookup | Array: limited size |
| Process Table | Find process by PID | List: O(n) |

## Implementing Hash Functions

A good hash function distributes keys uniformly across buckets:

```c
/* Hash function for SPT entries - hash the virtual address */
static unsigned
spt_hash (const struct hash_elem *e, void *aux UNUSED)
{
  struct spt_entry *spte = hash_entry(e, struct spt_entry, elem);
  return hash_bytes(&spte->upage, sizeof(spte->upage));
}

/* Comparison function for SPT entries */
static bool
spt_less (const struct hash_elem *a,
          const struct hash_elem *b,
          void *aux UNUSED)
{
  struct spt_entry *sa = hash_entry(a, struct spt_entry, elem);
  struct spt_entry *sb = hash_entry(b, struct spt_entry, elem);
  return sa->upage < sb->upage;
}
```

## Quiz: Hash Table Concepts

<Quiz
  title="Hash Table Quiz"
  topic="Data Structures"
  questions={[
    {
      question: 'What is the average time complexity for hash table lookup?',
      options: [
        { text: 'O(n)', isCorrect: false },
        { text: 'O(log n)', isCorrect: false },
        { text: 'O(1)', isCorrect: true },
        { text: 'O(n log n)', isCorrect: false },
      ],
      explanation: 'Hash tables provide O(1) average-case lookup. Worst case is O(n) if all elements hash to the same bucket, but good hash functions make this unlikely.',
    },
    {
      question: 'Why does PintOS embed hash_elem in your structure instead of storing pointers?',
      options: [
        { text: 'It uses less memory (no separate allocation)', isCorrect: true },
        { text: 'It is faster to access', isCorrect: false },
        { text: 'It is required by the C standard', isCorrect: false },
        { text: 'It prevents memory leaks', isCorrect: false },
      ],
      explanation: 'Intrusive data structures avoid separate allocations for container nodes. The hash_elem lives inside your structure, so no extra malloc is needed.',
    },
    {
      question: 'What does hash_entry() do?',
      options: [
        { text: 'Inserts an element into the hash table', isCorrect: false },
        { text: 'Returns the containing structure from a hash_elem', isCorrect: true },
        { text: 'Computes the hash value', isCorrect: false },
        { text: 'Removes an element from the hash table', isCorrect: false },
      ],
      explanation: 'hash_entry() uses pointer arithmetic (via offsetof) to convert a hash_elem pointer back to a pointer to your containing structure.',
    },
  ]}
/>

## Tips for PintOS

1. **Always initialize**: Call `hash_init()` before using a hash table
2. **Define both functions**: You need both a hash function and a comparison function
3. **Use `hash_bytes`**: It's optimized for hashing arbitrary data
4. **Clean up**: Use `hash_destroy()` with a destructor to free elements
